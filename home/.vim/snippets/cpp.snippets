extends c

snippet bend "$1.begin(), $1.end()"
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet pair
typedef std::pair<${2:int}, ${3:int}> `!p snip.rv = 'p'+t[1][0]+t[2][0]`
endsnippet

snippet cl "class .. (class)"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
	${1/(\w+).*/$1/}(${2:arguments});
	virtual ~${1/(\w+).*/$1/} ();
private:
	${0:/* data */}
};
endsnippet

snippet map "std::map (map)"
std::map<${1:key}, ${2:value}> map$0;
endsnippet

snippet vector "std::vector (v)"
std::vector<${1:char}> v$0;
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:_InputIter}>
endsnippet

snippet fenwick
void fenwickAdd(vector<int> &fenwick, int x, int delta)
{
    for (; x < fenwick.size(); x |= x+1)
        fenwick[x] += delta;
}

void fenwickGetSum(vector<int> &fenwick, int x)
{
    int ret = 0;
    for (; x; x &= x-1)
        ret += fenwick[x-1];
    return ret;
}
endsnippet

snippet heavylight
vector<int> e[${1:N}];
vector<int> fenwick[$1];
int vc[$1], // vertex to chain index
    vpos[$1], // vertex to chain position
    cp[$1]; // chain parent

pii hang(int u, int p)
{
    int size = 1;
    pii ret(0, -1);
    for (vector<int>::const_iterator it = e[u].begin(); it != e[u].end(); ++it)
        if (*it != p) {
            pii t = hang(*it, u);
            size += t.first;
            ret = max(ret, t);
        }

    e[u].clear();
    if (size == 1) ret.second = u;
    e[ret.second].push_back(u);
    cp[ret.second] = p;

    ret.first = size;
    return ret;
}

void heavyLight(int n)
{
    hang(0, -1);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < e[i].size(); ++j) {
            vc[e[i][j]] = i;
            vpos[e[i][j]] = j;
        }
}

struct ChainPart
{
    ChainPart(int chain, int lo, int hi) : chain(chain), lo(lo), hi(hi) {}
    int chain, lo, hi;
};

vector<ChainPart> chainPath(int u, int v)
{
    vector<pii> cu, cv;
    for (; u != -1; u = cp[vc[u]])
        cu.push_back(pii(vc[u], vpos[u]));
    reverse(cu.begin(), cu.end());
    for (; v != -1; v = cp[vc[v]])
        cv.push_back(pii(vc[v], vpos[v]));
    reverse(cv.begin(), cv.end());
    if (cu.size() > cv.size())
        cu.swap(cv);

    vector<ChainPart> ret;
    int i;
    for (i = 0; i < cu.size() && cu[i] == cv[i]; ++i);
    if (i == cu.size())
        ;
    else if (cu[i].first == cv[i].first) {
        ret.push_back( ChainPart(cu[i].first
                     , min(cu[i].second, cv[i].second)
                     , max(cu[i].second, cv[i].second)
                     ));
        ++i;
    }
    for (int j = i; j < cu.size(); ++j)
        ret.push_back(ChainPart(cu[j].first, cu[j].second, e[cu[j].first].size()));
    for (int j = i; j < cv.size(); ++j)
        ret.push_back(ChainPart(cv[j].first, cv[j].second, e[cv[j].first].size()));
    return ret;
}
endsnippet

# vim:ft=snippets:
