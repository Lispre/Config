extends c

snippet bend "$1.begin(), $1.end()"
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet pair
typedef pair<${1:int}, ${2:int}> `!p snip.rv = 'p'+t[1][0]+t[2][0]`
endsnippet

snippet foit "for int loop (foi)"
for (${1:vector}<${2:int}>::iterator ${3:i} = ${4:a}.begin(); $3 != $4.end(); ++$3) {
  ${0:/* code */}
}
endsnippet

snippet mainw "main()"
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#include <algorithm>
#include <cstdio>
#include <functional>
#include <map>
#include <set>
#include <utility>
#include <vector>
using namespace std;

typedef int64_t ll;
#define EACH(i, a) for (__typeof((a).begin()) i = (a).begin(); i != (a).end(); ++i)
#define REP(i, n) for (int i = 0; i < (n); i++)
#define REP1(i, n) for (int i = 1; i <= (n); i++)
#define FOR(i, a, b) for (int i = (a); i < (b); i++)
#define ROF(i, a, b) for (int i = (b); --i >= (a); )
#define pb push_back
#define mp make_pair
#define fi first
#define se second

typedef vector<int> VI;
typedef pair<int, int> PII;

int ri()
{
  int x;
  scanf("%d", &x);
  return x;
}

int main()
{
  $0
}
endsnippet

snippet main
int main()
{
  $0
}
endsnippet

snippet cl "class .. (class)"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
  ${1/(\w+).*/$1/}(${2:arguments});
  virtual ~${1/(\w+).*/$1/} ();
protected:
  ${0:/* data */}
};
endsnippet

snippet map "std::map (map)"
map<${1:int}, ${2:int}> $0;
endsnippet

snippet vector "std::vector (v)"
vector<${1:int}> $0;
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:_InputIter}>
endsnippet

snippet fenwick
void add(int a[], int n, int x, int delta)
{
  for (; x < n; x |= x+1)
    fenwick[x] += delta;
}

void getSum(int a[], int x)
{
  int sum = 0;
  for (; x; x &= x-1)
    sum += fenwick[x-1];
  return sum;
}
endsnippet

snippet heavylight
endsnippet

snippet minv
${1:a} = min($1, ${2:b});
endsnippet

snippet maxv
${1:a} = max($1, ${2:b});
endsnippet

snippet ll
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#include <stdint.h>

#ifndef LLONG_MAX
#define LLONG_MAX 9223372036854775807LL
#endif

typedef int64_t i64;
endsnippet

snippet using
using namespace std;
endsnippet

snippet suffix
struct P
{
  int key[2], id;
  bool operator<(const P &rhs) const {
    return key[0] < rhs.key[0] || key[0] == rhs.key[0] && key[1] < rhs.key[1];
  }
} sa[N], sa2[N];

void radix_sort(P *sa, P *sa2, int n, int k)
{
  fill_n(lcp, n, 0);
  REP(i, n)
    lcp[sa[i].key[k]]++;
  FOR(i, 1, n)
    lcp[i] += lcp[i-1];
  ROF(i, 0, n)
    sa2[--lcp[sa[i].key[k]]] = sa[i];
}

void suffix_array(const char a[], int n)
{
  REP(i, n)
    sa[i].id = i, sa[i].key[0] = a[i], sa[i].key[1] = 0;
  sort(sa, sa+n);
  for (int k = 1; ; k *= 2) {
    rnk[sa[0].id] = 0;
    FOR(i, 1, n)
      rnk[sa[i].id] = rnk[sa[i-1].id] + (sa[i-1] < sa[i]);
    if (k >= n || rnk[sa[n-1].id] == n-1) break;
    REP(i, n) {
      sa[i].id = i;
      sa[i].key[0] = rnk[i];
      sa[i].key[1] = i+k < n ? rnk[i+k]+1 : 0;
    }
    radix_sort(sa, sa2, n, 1);
    radix_sort(sa2, sa, n, 0);
  }
  for (int k = 0, i = 0; i < n; i++)
    if (rnk[i]) {
      for (int j = sa[rnk[i]-1].id; a[j+k] == a[i+k]; k++);
      lcp[rnk[i]] = k;
      if (k) k--;
    }
}
endsnippet

snippet morris
void morrisPratt(int n)
{
  pi[0] = 0;
  for (int j = 0, i = 1; i < n; i++) {
    while (j && a[j] != a[i]) j = pi[j-1];
    if (a[j] == a[i]) j++;
    pi[i] = j;
  }
}
endsnippet

snippet lmcs
int i = 0, j = 1;
while (i < n && j < n) {
  int k = 0;
  while (k < n && a[(i+k)%n] == a[(j+k)%n])
    k++;
  if (a[(i+k)%n] < a[(j+k)%n]) j += k+1;
  else i += k+1;
  if (i == j) j++;
}
endsnippet

snippet prime
int pr[N/10], np = 0;
bool sieved[N];

void getPrimes()
{
    for (int i = 2; i < N; i++) {
        if (!sieved[i]) pr[np++] = i;
        for (int j = 0; j < np && i*pr[j] < N; j++) {
            sieved[i*pr[j]] = true;
            if (i%pr[j] == 0) break;
        }
    }
}
endsnippet

snippet exgcd
ll exgcd(ll a, ll b, ll &x, ll &y)
{
    if (!b) return x = 1, y = 0, a;
    ll gcd = exgcd(b, a%b, y, x);
    y -= a/b*x;
    return gcd;
}
endsnippet

snippet vec
struct Vec
{
  double x, y;
  Vec() {}
  Vec(double x, double y) : x(x), y(y) {}
  double cross(Vec a, Vec b) const {
    return (a.x - x) * (b.y - y) - (a.y - y) * (b.x - x);
  }
  Vec operator+(Vec r) const { return Vec(x + r.x, y + r.y); }
  Vec operator*(double r) const { return Vec(x * r, y * r); }
  Vec operator/(double r) const { return Vec(x / r, y / r); }
} $0;
endsnippet

snippet l2l
Vec lineIntersectLine(Line p, Line q)
{
  double s = p.a.cross(q.a, p.b),
    t = p.a.cross(p.b, q.b);
  return (q.a * t + q.b * s) / (s + t);
}
endsnippet

snippet area
double polygonArea(const Vec pt[], int n)
{
  double area = 0;
  Vec o(0, 0);
  for (int i = 0; i < n; i++)
    area += o.cross(pt[i], pt[(i+1)%n]);
  return area / 2;
}
endsnippet

snippet halfp
bool cmp_ang(Line p, Line q)
{
  if (fabs(p.ang - q.ang) > eps) return p.ang < q.ang;
  return q.a.cross(q.b, p.a) > 0;
}

int halfPlane(Line* a, int n, Vec* pt)
{
  sort(a, a+n, cmp_ang);

  int m = 1;
  for (int i = 1; i < n; i++)
    if (fabs(a[i].ang - a[i-1].ang) > eps)
      a[m++] = a[i];

  int bot = 0, top = 1;
  for (int i = 2; i < m; i++) {
    while (bot < top && a[i].a.cross(a[i].b, lineIntersectLine(a[top-1], a[top])) < -eps)
      top--;
    while (bot < top && a[i].a.cross(a[i].b, lineIntersectLine(a[bot], a[bot+1])) < -eps)
      bot++;
    a[++top] = a[i];
  }
  while (bot < top && a[bot].a.cross(a[bot].b, lineIntersectLine(a[top-1], a[top])) < -eps)
    top--;
  while (bot < top && a[top].a.cross(a[top].b, lineIntersectLine(a[bot], a[bot+1])) < -eps)
    bot++;

  if (top - bot < 2) return 0;
  m = 0;
  for (int i = bot; i < top; i++)
    pt[m++] = lineIntersectLine(a[i], a[i+1]);
  pt[m++] = lineIntersectLine(a[top], a[bot]);
  return m;
}
endsnippet

snippet scc
int scc[N], dfn[N], nscc, tick;
vector<int> e[N];

int tarjanScc(int u)
{
  static stack<int> S;
  dfn[u] = tick;
  int low = tick++;
  S.push(u);
  for (vector<int>::iterator i = e[u].begin(); i != e[u].end(); ++i)
    if (dfn[*i] == -1)
      low = min(low, tarjanScc(*i));
    else if (scc[*i] == -1)
      low = min(low, dfn[*i]);
  if (low == dfn[u]) {
    int v;
    do scc[v = S.top()] = nscc, S.pop();
    while (v != u);
    nscc++;
  }
  return low;
}

fill_n(dfn, n, -1);
fill_n(scc, n, -1);
nscc = 0;
for (int i = 0; i < n; i++)
  if (dfn[i] == -1)
    tarjanScc(i);
endsnippet

snippet bridge
int bcc[N], dfn[N], parent[N], nbcc, tick;
struct Edge
{
  Edge *next, *pair;
  int v;
} *e[N], *ee[N], pool[M*2], *pit;

int bridgeConnected(int u, Edge* pre)
{
  static stack<int> S;
  dfn[u] = tick;
  int low = tick++;
  S.push(u);
  for (Edge* i = e[u]; i; i = i->next)
    if (dfn[i->v] == -1) {
      parent[i->v] = u;
      low = min(low, bridgeConnected(i->v, i));
      // if (low[i->v] > dfn[u]) then mark i as bridge
    } else if (i->pair != pre)
      low = min(low, dfn[i->v]);
  if (low == dfn[u]) {
    int v;
    do bcc[v = S.top()] = nbcc, S.pop(), sum[nbcc] += val[v];
    while (v != u);
    nbcc++;
  }
  return low;
}
endsnippet

snippet fi
#define fi first
endsnippet

snippet se
#define se second
endsnippet

snippet ALL
#define ALL(x) (x).begin(), (x).end()
endsnippet

snippet blankinship
ll blankinship(ll a, ll b, ll &x, ll &y)
{
  for (ll u = y = 1, v = x = 0; a; ) {
    ll q = b/a;
    swap(x -= q*u, u);
    swap(y -= q*v, v);
    swap(b -= q*a, a);
  }
  return b;
}
endsnippet

snippet mul_mod
ll mul_mod(ll a, ll b, ll mod)
{ 
  // mod < 2**62
  ll x = a*b, r = x - mod*ll(double(a)*double(b)/mod+0.5);
  return r < 0 ? r + mod : r;
}
endsnippet

snippet inv
ll inv(ll a, ll mod)
{
  ll x, y;
  blankinship(a, mod, x, y);
  return x < 0 ? x + mod : x;
}
endsnippet

snippet pow_mod
ll pow_mod(ll a, ll b, ll mod)
{
  ll r = 1;
  for (; b; b >>= 1) {
    if (b & 1)
      r = r * a % mod;
    a = a * a % mod;
  }
  return r;
}
endsnippet

snippet find
int find(int x)
{
  while (uf[x] >= 0) {
    if (uf[uf[x]] >= 0)
      uf[x] = uf[uf[x]];
    x = uf[x];
  }
  return x;
}
endsnippet

snippet lct
namespace LCT
{
  extern struct Node null;
  struct Edge;
  struct Node {
    int flip, w;
    Node *c[2], *p, *opt;
    void init() {
      c[0] = c[1] = p = &null;
      flip = 0;
      w = -1;
      opt = this;
    }
    void mconcat() {
      opt = this;
      REP(d, 2)
        if (c[d]->opt->w > opt->w)
          opt = c[d]->opt;
    }
    void setc(int d, Node *x) {
      c[d] = x;
      x->p = this;
      mconcat();
    }
    void untag() {
      if (! flip) return;
      flip = 0;
      c[0]->flip ^= 1;
      c[1]->flip ^= 1;
      swap(c[0], c[1]);
    }
    void zag(int d) {
      Node *x = c[d], *p = this->p;
      setc(d, x->c[d^1]);
      x->setc(d^1, this);
      x->p = p;
      if (p->c[0] == this)
        p->c[0] = x;
      else if (p->c[1] == this)
        p->c[1] = x;
    }
    void splay() {
      while (p->c[0] == this || p->c[1] == this) {
        Node *p = this->p, *g = p->p;
        if (g->c[0] == p || g->c[1] == p) {
          g->untag();
          p->untag();
          untag();
          if (g->c[0] == p) {
            if (p->c[0] != this)
              p->zag(1);
            g->zag(0);
          } else {
            if (p->c[0] == this)
              p->zag(0);
            g->zag(1);
          }
        } else {
          p->untag();
          untag();
          p->zag(p->c[0] != this);
        }
      }
      untag();
    }
    void expose() {
      Node *x = this, *y = &null;
      for (; x != &null; y = x, x = x->p) {
        x->splay();
        x->setc(1, y);
      }
      splay();
    }
    void evert() {
      expose();
      flip = 1;
    }
    bool same_root(Node *o) {
      expose();
      o->expose();
      return p != &null;
    }
    void link(Node *o) {
      o->evert();
      o->p = this;
    }
    void cut(Node *o) {
      evert();
      o->expose();
      p = &null;
      o->setc(0, &null);
    }
    Edge *query(Node *o) {
      evert();
      o->expose();
      return (Edge *)o->opt;
    }
  } null, nodes[N];
  struct Edge : Node { Node *x, *y; } edges[N];
};
endsnippet

# vim:ft=snippets:
